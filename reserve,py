import logging
import json
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, CallbackContext, ConversationHandler, CallbackQueryHandler

# Setup logging
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# Constants
PRODUCTS_FILE = 'products.json'
NAME, PHONE, ADDRESS, CONFIRM, ORDER_CHOICE, ORDER_DETAILS = range(6)
user_data = {}
orders = {}
cart = {}

def start(update: Update, context: CallbackContext) -> int:
    update.message.reply_text("Welcome! Please provide your name.")
    return NAME

def name(update: Update, context: CallbackContext) -> int:
    context.user_data['name'] = update.message.text
    update.message.reply_text("What is your phone number?")
    return PHONE

def phone(update: Update, context: CallbackContext) -> int:
    context.user_data['phone'] = update.message.text
    update.message.reply_text("What is your address?")
    return ADDRESS

def address(update: Update, context: CallbackContext) -> int:
    context.user_data['address'] = update.message.text
    user_details = f"Name: {context.user_data['name']}\nPhone: {context.user_data['phone']}\nAddress: {context.user_data['address']}"
    keyboard = [
        [InlineKeyboardButton("Confirm", callback_data='confirm')],
        [InlineKeyboardButton("Edit", callback_data='edit')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    update.message.reply_text(f"Please confirm your details:\n{user_details}", reply_markup=reply_markup)
    return CONFIRM


def show_products(update: Update, context: CallbackContext) -> int:
    products = load_products()
    context.user_data['products'] = products
    context.user_data['current_product'] = 0
    send_product(update, context)
    return ORDER_CHOICE

def load_products():
    try:
        with open(PRODUCTS_FILE, 'r') as file:
            return json.load(file)
    except Exception as e:
        logger.error(f"Error loading products: {e}")
        return []

def send_product(update: Update, context: CallbackContext):
    products = context.user_data.get('products', [])
    current_index = context.user_data.get('current_product', 0)
    
    # Determine whether we're handling a callback query or a regular message
    message = update.message or update.callback_query.message

    if 0 <= current_index < len(products):
        product = products[current_index]
        caption = f"Name: {product.get('name')}\nDescription: {product.get('description')}\nPrice: {product.get('price')}"
        
        try:
            # Check if the image URL is local or remote
            image_url = product.get('image')
            if image_url.startswith(('http://', 'https://')):
                message.reply_photo(
                    photo=image_url,
                    caption=caption,
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("Order Now", callback_data=f'order_{product["id"]}')],
                        [InlineKeyboardButton("Next Item", callback_data='next_product')],
                        [InlineKeyboardButton("Home", callback_data='home')]
                    ])
                )
            else:
                # Handle local file paths
                with open(image_url, 'rb') as image_file:
                    message.reply_photo(
                        photo=image_file,
                        caption=caption,
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton("Order Now", callback_data=f'order_{product["id"]}')],
                            [InlineKeyboardButton("Next Item", callback_data='next_product')],
                            [InlineKeyboardButton("Home", callback_data='home')]
                        ])
                    )
        except FileNotFoundError:
            message.reply_text(f"Image file for {product.get('name')} not found.")
            context.user_data['current_product'] += 1
            send_product(update, context)  # Retry with the next product
    else:
        message.reply_text("No more products available.")
        context.user_data['products'] = []
        context.user_data['current_product'] = 0
        return ConversationHandler.END


def handle_product_navigation(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    query.answer()
    data = query.data

    current_index = context.user_data.get('current_product', 0)
    products = context.user_data.get('products', [])
    
    if data == 'next_product':
        current_index = (current_index + 1) % len(products)
    elif data == 'previous_product':
        current_index = (current_index - 1) % len(products)
    elif data.startswith('add_'):
        product_id = int(data.split('_')[1])
        product = next((p for p in products if p['id'] == product_id), None)
        if product:
            cart.setdefault(query.message.chat.id, []).append(product)
            query.message.reply_text(f"Added {product['name']} to cart.")
        return ORDER_CHOICE

    context.user_data['current_product'] = current_index
    send_product(update, context)
    return ORDER_CHOICE

def view_cart(update: Update, context: CallbackContext) -> None:
    user_cart = cart.get(update.message.chat.id, [])
    if not user_cart:
        update.message.reply_text("Your cart is empty.")
        return

    cart_details = "\n".join([f"{p['name']} - {p['price']}" for p in user_cart])
    update.message.reply_text(f"Your cart:\n{cart_details}")

    keyboard = [[InlineKeyboardButton("Checkout", callback_data='checkout')]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    update.message.reply_text("Proceed to checkout?", reply_markup=reply_markup)

def checkout(update: Update, context: CallbackContext) -> None:
    user_cart = cart.get(update.message.chat.id, [])
    if not user_cart:
        update.message.reply_text("Your cart is empty.")
        return

    total_amount = sum(p['price'] for p in user_cart)
    update.message.reply_text(
        f"Please pay {total_amount} to the following bank account:\n\n"
        f"**Bank Name:** Example Bank\n"
        f"**Account Number:** 123-456-789\n"
        f"**Account Name:** Drop Shipping Bot\n\n"
        f"Once you've made the payment, please upload a screenshot of the payment proof."
    )
    context.user_data['pending_order'] = user_cart
    cart[update.message.chat.id] = []  # Clear cart

def receive_payment_proof(update: Update, context: CallbackContext) -> None:
    photo = update.message.photo[-1].get_file().download()
    update.message.reply_text("Thank you! Your payment proof has been received and is pending approval.")
    context.bot.send_message(
        chat_id=1234567890,  # Replace with admin chat ID
        text="New payment proof received. Please review."
    )

def approve_order(update: Update, context: CallbackContext) -> None:
    # Admin approves the order
    context.bot.send_message(
        chat_id=update.message.chat.id,
        text="Your order has been approved and is being processed."
    )

def handle_user_selection(update: Update, context: CallbackContext) -> None:
    text = update.message.text
    if text == 'Available Products':
        show_products(update, context)
    elif text == 'My Cart':
        view_cart(update, context)
    elif text == 'Checkout':
        checkout(update, context)
    return ConversationHandler.END

def main() -> None:
    updater = Updater("7289662775:AAEeOB-MiJNYJSToqr3TATuAVtY-N9f0Ke4", use_context=True)
    dispatcher = updater.dispatcher

    dispatcher.add_handler(CommandHandler('start', start))
    dispatcher.add_handler(MessageHandler(Filters.text & ~Filters.command, handle_user_selection))
    dispatcher.add_handler(CallbackQueryHandler(handle_product_navigation, pattern='^add_|^next_product|^previous_product|^home$'))
    dispatcher.add_handler(MessageHandler(Filters.photo, receive_payment_proof))
    dispatcher.add_handler(MessageHandler(Filters.regex('^Checkout$'), checkout))
    dispatcher.add_handler(MessageHandler(Filters.regex('^Approve Order$'), approve_order))

    updater.start_polling()
    updater.idle()

if __name__ == '__main__':
    main()
